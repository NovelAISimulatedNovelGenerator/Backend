# NovelAI 系统架构概述

## 系统概述

NovelAI是一个基于AI技术的小说生成和管理系统，采用Hertz框架构建，以模块化、低耦合的方式组织代码，提供用户管理、世界观设计、创作内容保存等核心功能。本文档提供系统架构的全局视角，展示各组件间的关系和数据流转。

## 架构设计原则

NovelAI项目遵循以下核心设计原则：

1. **分层架构**: 清晰区分API层、业务逻辑层和数据访问层
2. **模块化设计**: 功能按领域划分为独立模块，实现高内聚低耦合
3. **函数式编程风格**: 优先使用纯函数，明确类型定义，减少副作用
4. **统一错误处理**: 标准化的错误响应格式和错误传递机制
5. **完善文档**: 文档与代码同等重要，采用层次化结构组织文档
6. **可测试性**: 组件设计便于单元测试和集成测试
7. **安全优先**: 内置安全实践，如密码加密、访问控制、输入验证

## 系统架构图

```
+------------------+
|    客户端层      |
|   Web / Mobile   |
+--------+---------+
         |
         v
+--------+---------+
|     API层        |
|   Hertz Router   |
+--------+---------+
         |
         v
+--------+---------+
|   Handler层      |
| 请求处理与验证    |
+--------+---------+
         |
         v
+--------+---------+
|   Service层      |
|   业务逻辑处理    |
+--------+---------+
         |
         v
+--------+---------+
|   Data访问层     |
|  GORM / 数据库   |
+--------+---------+
         |
         v
+--------+---------+
|   持久化存储      |
|   PostgreSQL     |
+------------------+
```

## 核心组件

### 1. API层 (Router)

API层负责HTTP路由定义和请求分发，是外部与系统交互的入口。

- **位置**: `/router`
- **职责**: 
  - 定义HTTP路由
  - 集成中间件 (认证、日志、限流)
  - 请求分发到对应Handler

### 2. Handler层

Handler层负责请求处理、参数验证和响应构造，是连接API和业务逻辑的桥梁。

- **位置**: `/biz/handler`
- **职责**:
  - 请求参数绑定和验证
  - 调用Service层执行业务逻辑
  - 构造统一格式的HTTP响应
  - 错误处理与转换

#### 主要模块:
- **用户处理器** (`user/user_handler.go`): 处理用户注册、登录、信息管理
- **保存处理器** (`save/save_handler.go`): 处理用户创作内容的保存操作
- **背景处理器** (`background/background_service.go`): 处理小说背景设定管理

### 3. Service层

Service层包含所有业务逻辑实现，是系统的核心部分，负责实现业务规则和流程。

- **位置**: `/biz/service`
- **职责**:
  - 实现业务逻辑和规则
  - 协调多个数据访问操作
  - 数据转换和处理
  - 错误处理与业务错误定义

#### 主要模块:
- **用户服务** (`user/user_service.go`): 用户账户管理逻辑
- **保存服务** (`save/save_service.go`): 创作内容保存逻辑
- **背景生成服务** (`background/generate.go`): 小说背景生成逻辑

### 4. 数据访问层 (DAL)

数据访问层负责与数据库交互，提供数据持久化和检索功能。

- **位置**: `/biz/dal`
- **职责**:
  - 定义数据模型
  - 提供CRUD操作接口
  - 处理数据库事务
  - 错误处理与数据库错误转换

#### 主要模块:
- **数据库初始化** (`db/init.go`): 数据库连接管理
- **用户数据访问** (`db/user.go`): 用户相关数据操作
- **保存数据访问** (`db/save.go`): 保存项相关数据操作

### 5. 公共组件

- **位置**: `/pkg`
- **常量定义** (`constants`): 系统常量定义
- **中间件** (`middleware`): JWT认证、日志、跨域等中间件
- **工具函数** (`utils`): 加密、ID生成等通用工具

## 数据模型

系统的核心数据模型包括：

### 用户模型 (User)
```
- ID: 用户唯一标识
- Username: 用户名
- Password: 加密密码
- Nickname: 用户昵称
- Email: 电子邮箱
- Avatar: 头像URL
- Status: 用户状态
```

### 保存模型 (Save)
```
- ID: 保存项唯一标识
- UserID: 所属用户ID
- SaveID: 业务标识符
- SaveName: 保存项名称
- SaveDescription: 保存项描述
- SaveData: 保存的具体内容
- SaveType: 保存类型
- SaveStatus: 保存状态
```

### 背景模型
```
- Worldview: 世界观设定
- Rule: 世界规则
- BackgroundInfo: 背景信息
```

## 请求流程

以用户登录为例，典型请求的完整流程如下：

1. 客户端发送登录请求到 `/user/login` 接口
2. Router将请求路由到 `user.Login` 处理函数
3. Handler绑定并验证请求参数
4. Handler调用 `UserService.Login` 方法
5. Service层验证用户凭据
6. Service层调用数据访问层验证用户名和密码
7. 数据访问层执行数据库查询
8. 验证结果返回给Service层
9. Service层生成JWT令牌
10. Handler构造HTTP响应并返回

## 错误处理

系统采用分层级的错误处理机制：

1. **数据访问层**: 定义数据操作相关错误，如 `ErrUserNotFound`
2. **Service层**: 定义业务逻辑错误，可能封装或转换数据访问层错误
3. **Handler层**: 将错误转换为HTTP响应，设置适当的状态码和错误消息

错误响应格式统一为：
```json
{
  "code": <错误码>,
  "message": "<错误描述>"
}
```

## 安全设计

1. **认证机制**: 基于JWT的身份验证
2. **密码安全**: 使用加密算法存储密码
3. **输入验证**: 所有请求参数严格验证
4. **数据隔离**: 用户只能访问自己的数据
5. **错误消息**: 避免在错误消息中泄露敏感信息

## 扩展性考虑

1. **水平扩展**: 无状态设计便于多实例部署
2. **垂直扩展**: 模块化设计便于添加新功能
3. **替换组件**: 接口设计允许替换具体实现，如数据库驱动
4. **API版本**: 支持API版本管理

## 部署架构

系统可以部署为单体应用或微服务架构：

### 单体部署
```
[客户端] <-> [负载均衡器] <-> [NovelAI应用] <-> [数据库]
```

### 微服务部署
```
[客户端] <-> [API网关] <-> [用户服务/保存服务/背景服务] <-> [数据库]
```

## 监控与日志

1. **日志系统**: 使用Hertz的hlog包记录系统日志
2. **性能监控**: 支持通过OpenTracing进行分布式追踪
3. **健康检查**: 提供 `/ping` 接口用于健康检查

## 相关文档

- [Proto文件概述](./proto_overview.md): 服务接口定义
- [Handler层文档](./handler_overview.md): 请求处理逻辑
- [Service层文档](./service_overview.md): 业务逻辑实现
- [数据访问层文档](./dal_overview.md): 数据存储和访问
